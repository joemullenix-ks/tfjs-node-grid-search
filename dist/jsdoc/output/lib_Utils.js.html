<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>lib/Utils.js - Documentation</title>
    <link rel="icon" type="image/png" href="favicon.png"/>

    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Axis.html">Axis</a><ul class='methods'><li data-type='method'><a href="Axis.html#.AttemptValidateParameter">AttemptValidateParameter</a></li><li data-type='method'><a href="Axis.html#.AttemptValidateProgression">AttemptValidateProgression</a></li><li data-type='method'><a href="Axis.html#.LookupTypeName">LookupTypeName</a></li><li data-type='method'><a href="Axis.html#Advance">Advance</a></li><li data-type='method'><a href="Axis.html#CalculatePosition">CalculatePosition</a></li><li data-type='method'><a href="Axis.html#CheckComplete">CheckComplete</a></li><li data-type='method'><a href="Axis.html#Reset">Reset</a></li><li data-type='method'><a href="Axis.html#WriteReport">WriteReport</a></li></ul></li><li><a href="AxisSet.html">AxisSet</a><ul class='methods'><li data-type='method'><a href="AxisSet.html#AdvanceAxis">AdvanceAxis</a></li><li data-type='method'><a href="AxisSet.html#CheckAxisComplete">CheckAxisComplete</a></li><li data-type='method'><a href="AxisSet.html#CreateParams">CreateParams</a></li><li data-type='method'><a href="AxisSet.html#GetTotalAxes">GetTotalAxes</a></li><li data-type='method'><a href="AxisSet.html#ResetAxis">ResetAxis</a></li><li data-type='method'><a href="AxisSet.html#Walk">Walk</a></li><li data-type='method'><a href="AxisSet.html#WriteAxisReport">WriteAxisReport</a></li></ul></li><li><a href="AxisSetTraverser.html">AxisSetTraverser</a><ul class='methods'><li data-type='method'><a href="AxisSetTraverser.html#Advance">Advance</a></li><li data-type='method'><a href="AxisSetTraverser.html#CreateIterationParams">CreateIterationParams</a></li><li data-type='method'><a href="AxisSetTraverser.html#ExamineAxisNames">ExamineAxisNames</a></li><li data-type='method'><a href="AxisSetTraverser.html#LookupIterationDescriptor">LookupIterationDescriptor</a></li><li data-type='method'><a href="AxisSetTraverser.html#WriteReport">WriteReport</a></li></ul></li><li><a href="DataSet.html">DataSet</a></li><li><a href="DataSetFetcher.html">DataSetFetcher</a><ul class='methods'><li data-type='method'><a href="DataSetFetcher.html#Fetch">Fetch</a></li></ul></li><li><a href="EpochStats.html">EpochStats</a><ul class='methods'><li data-type='method'><a href="EpochStats.html#.WriteReportHeader">WriteReportHeader</a></li><li data-type='method'><a href="EpochStats.html#Update">Update</a></li><li data-type='method'><a href="EpochStats.html#WriteReport">WriteReport</a></li></ul></li><li><a href="ExponentialProgression.html">ExponentialProgression</a><ul class='methods'><li data-type='method'><a href="ExponentialProgression.html#Advance">Advance</a></li><li data-type='method'><a href="ExponentialProgression.html#Reset">Reset</a></li></ul></li><li><a href="FailureMessage.html">FailureMessage</a></li><li><a href="FibonacciProgression.html">FibonacciProgression</a><ul class='methods'><li data-type='method'><a href="FibonacciProgression.html#Advance">Advance</a></li><li data-type='method'><a href="FibonacciProgression.html#Reset">Reset</a></li></ul></li><li><a href="FileIOResult.html">FileIOResult</a></li><li><a href="Grid.html">Grid</a><ul class='methods'><li data-type='method'><a href="Grid.html#Run">Run</a></li></ul></li><li><a href="GridOptions.html">GridOptions</a><ul class='methods'><li data-type='method'><a href="GridOptions.html#GetOption">GetOption</a></li></ul></li><li><a href="GridRunStats.html">GridRunStats</a><ul class='methods'><li data-type='method'><a href="GridRunStats.html#AddIterationResult">AddIterationResult</a></li><li data-type='method'><a href="GridRunStats.html#WriteCSV">WriteCSV</a></li><li data-type='method'><a href="GridRunStats.html#WriteReport">WriteReport</a></li></ul></li><li><a href="IterationResult.html">IterationResult</a><ul class='methods'><li data-type='method'><a href="IterationResult.html#WriteEpochStatsHeader">WriteEpochStatsHeader</a></li><li data-type='method'><a href="IterationResult.html#WriteEpochStatsValues">WriteEpochStatsValues</a></li><li data-type='method'><a href="IterationResult.html#WriteModelParamHeader">WriteModelParamHeader</a></li><li data-type='method'><a href="IterationResult.html#WriteModelParamValues">WriteModelParamValues</a></li><li data-type='method'><a href="IterationResult.html#WriteReport">WriteReport</a></li><li data-type='method'><a href="IterationResult.html#WriteTestStatsHeader">WriteTestStatsHeader</a></li><li data-type='method'><a href="IterationResult.html#WriteTestStatsValues">WriteTestStatsValues</a></li></ul></li><li><a href="LinearProgression.html">LinearProgression</a><ul class='methods'><li data-type='method'><a href="LinearProgression.html#Advance">Advance</a></li><li data-type='method'><a href="LinearProgression.html#Reset">Reset</a></li></ul></li><li><a href="ModelParams.html">ModelParams</a><ul class='methods'><li data-type='method'><a href="ModelParams.html#GetBooleanParam">GetBooleanParam</a></li><li data-type='method'><a href="ModelParams.html#GetNumericParam">GetNumericParam</a></li><li data-type='method'><a href="ModelParams.html#GetTextParam">GetTextParam</a></li></ul></li><li><a href="ModelStatics.html">ModelStatics</a><ul class='methods'><li data-type='method'><a href="ModelStatics.html#AttemptStripParam">AttemptStripParam</a></li><li data-type='method'><a href="ModelStatics.html#GenerateInitializerBias">GenerateInitializerBias</a></li><li data-type='method'><a href="ModelStatics.html#GenerateInitializerKernel">GenerateInitializerKernel</a></li><li data-type='method'><a href="ModelStatics.html#GenerateLossFunction">GenerateLossFunction</a></li><li data-type='method'><a href="ModelStatics.html#GenerateOptimizer">GenerateOptimizer</a></li><li data-type='method'><a href="ModelStatics.html#ShallowCloneParams">ShallowCloneParams</a></li></ul></li><li><a href="ModelTestStats.html">ModelTestStats</a><ul class='methods'><li data-type='method'><a href="ModelTestStats.html#CalculateScore">CalculateScore</a></li></ul></li><li><a href="PredictionEvaluation.html">PredictionEvaluation</a></li><li><a href="Progression.html">Progression</a><ul class='methods'><li data-type='method'><a href="Progression.html#Reset">Reset</a></li></ul></li><li><a href="SessionData.html">SessionData</a><ul class='methods'><li data-type='method'><a href="SessionData.html#.CountLeafElements">CountLeafElements</a></li><li data-type='method'><a href="SessionData.html#.FindMean">FindMean</a></li><li data-type='method'><a href="SessionData.html#.FindStandardDeviation">FindStandardDeviation</a></li><li data-type='method'><a href="SessionData.html#.StandardizeInputs">StandardizeInputs</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-FileIO.html">FileIO</a><ul class='methods'><li data-type='method'><a href="module-FileIO.html#~ProduceResultsFilename">ProduceResultsFilename</a></li><li data-type='method'><a href="module-FileIO.html#~ReadDataFile">ReadDataFile</a></li><li data-type='method'><a href="module-FileIO.html#~WriteResultsFile">WriteResultsFile</a></li></ul></li><li><a href="module-main.html">main</a></li><li><a href="module-Utils.html">Utils</a><ul class='methods'><li data-type='method'><a href="module-Utils.html#~ArrayCalculateAverage">ArrayCalculateAverage</a></li><li data-type='method'><a href="module-Utils.html#~ArrayFindIndexOfHighestValue">ArrayFindIndexOfHighestValue</a></li><li data-type='method'><a href="module-Utils.html#~Assert">Assert</a></li><li data-type='method'><a href="module-Utils.html#~CheckFloat0to1Exclusive">CheckFloat0to1Exclusive</a></li><li data-type='method'><a href="module-Utils.html#~CheckNonNegativeInteger">CheckNonNegativeInteger</a></li><li data-type='method'><a href="module-Utils.html#~CheckPositiveInteger">CheckPositiveInteger</a></li><li data-type='method'><a href="module-Utils.html#~QueueRotate">QueueRotate</a></li><li data-type='method'><a href="module-Utils.html#~ThrowCaughtUnknown">ThrowCaughtUnknown</a></li><li data-type='method'><a href="module-Utils.html#~ValidateTextForCSV">ValidateTextForCSV</a></li><li data-type='method'><a href="module-Utils.html#~WriteDurationReport">WriteDurationReport</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">lib/Utils.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
//TODO: Merge these into the f lib, once that's integrated.
/**
 * @module Utils
 */
/**
 * Finds the mean of a set of numbers. Array must not be empty.
 * @param {Array&lt;number>} array
 * @return {number}
 */
const ArrayCalculateAverage = (array) => {
    if (array.length === 0) {
        throw new Error('Cannot calculate average. Array is empty.');
    }
    //TODO: Move into EpochStats, where these can be done more efficiently.
    //PERF: Don't walk the whole set. Instead, discount a running average (which
    //		we'll keep separately and pass in), by (droppedSample / total), then
    //		add (addedSample / total).
    const SUM = array.reduce((previous, current) => { return previous + current; }, 0);
    return SUM / array.length;
};
/**
 * Finds the largest value in an array of numbers, and returns the index of that
 * value. Array must not be empty.
 * @param {Array&lt;number>} values
 * @return {number}
 */
const ArrayFindIndexOfHighestValue = (values) => {
    if (values.length === 0) {
        throw new Error('Cannot find highest. Array is empty.');
    }
    let indexOfHighest = 0;
    let highestValue = Number.MIN_VALUE;
    for (let p = 0; p &lt; values.length; ++p) {
        if (values[p] &lt; highestValue) {
            continue;
        }
        indexOfHighest = p;
        highestValue = values[p];
    }
    return indexOfHighest;
};
/**
 * Standard assertion. Throws if condition is false.&lt;br>
 * Note: Todo: To better merge w/ Jest, I'll propagate this throughout, and
 * build in a preprocessor switch, driven by Node launch arg.
 * @param {boolean} condition
 * @return {void}
 */
const Assert = (condition) => {
    if (condition) {
        return;
    }
    throw new Error('assertion failed');
};
/**
 * Returns true if x is in the range { 0 &lt; x &lt; 1 }.
 * @param {number} x
 * @return {boolean}
 */
const CheckFloat0to1Exclusive = (x) => {
    if (x &lt;= 0) {
        return false;
    }
    if (x >= 1) {
        return false;
    }
    return true;
};
/**
 * Returns true if x is a positive integer or zero.
 * @param {number} x
 * @return {boolean}
 */
const CheckNonNegativeInteger = (x) => {
    if (x &lt; 0) {
        return false;
    }
    if (x !== Math.floor(x)) {
        return false;
    }
    return true;
};
/**
 * Returns true if x is an integer greater than zero.
 * @param {number} x
 * @return {boolean}
 */
const CheckPositiveInteger = (x) => {
    if (!CheckNonNegativeInteger(x)) {
        return false;
    }
    if (x &lt; 1) {
        return false;
    }
    return true;
};
/**
 * Fills a queue with numbers up to a length limit. Once that limit has been
 * reached, it drops the oldest first (does a dequeue before the enqueue).
 * @param {Array&lt;number>} queue The set of numbers.
 * @param {number} newSample The number to add.
 * @param {number} count The queue max-size limit.
 */
const QueueRotate = (queue, newSample, count) => {
    if (count &lt; 1) {
        throw new Error('queue length limit must be >= 1 :' + count);
    }
    queue.push(newSample);
    if (queue.length &lt;= count) {
        return;
    }
    queue.shift();
};
/**
 * Throws a relayed exception, with logic that checks the type of the
 * caught object in order produce a cleaner error message.&lt;br>
 * Note: This is done because TypeScript does not yet have typed catch().
 * @param {string} messagePrefix A short message to prepend to the thrown error.
 * @param {unknown} errorOrException The object originally caught.
 */
const ThrowCaughtUnknown = (messagePrefix, errorOrException) => {
    if (typeof errorOrException === 'string') {
        throw new Error(messagePrefix + errorOrException);
    }
    if (errorOrException instanceof Error) {
        throw new Error(messagePrefix + errorOrException.message);
    }
    throw new Error(messagePrefix + 'unknown exception type');
};
/**
 * Takes arguments in a variety of types, converts them to strings, and checks
 * whether those string representations will break CSV formatting. Specifically,
 * it throws in the event it finds a comma or newline. Otherwise it returns
 * silently.
 * @param {(string | number | boolean)} x
 */
const ValidateTextForCSV = (x) => {
    //NOTE: Add whichever (just not TS any) input type. That's the point, here. We're looking at the argument
    //		after it's been cast to string, to ensure we have cleanly CSV-able information for file write().
    //
    //UPDATE: Now that this takes primitives only, it should likely be string-only.
    //		  There is a growing case to toss it entirely. Stay tuned for the
    //		  complex axes (e.g. activation functions, etc...).
    const AS_STRING = x.toString();
    if (AS_STRING.indexOf(',') === -1 &amp;&amp; AS_STRING.indexOf('\n') === -1) {
        return;
    }
    throw new Error('Value contains comma or newline (which interferes with CSV): ' + x + ', ' + AS_STRING);
};
/**
 * Creates a string that represents a duration in milliseconds, and variations
 * of the same in seconds, minutes and hours.
 * @param {number} durationMS The time in milliseconds
 * @return {string} Example: "15000 ms / 15.00 sec / 0.25 min / 0.0 hr"
 */
const WriteDurationReport = (durationMS) => {
    Assert(durationMS >= 0);
    //TODO: (low-pri) Bring in time-reporting from the f lib, which has smart duration-category picking.
    return durationMS + ' ms'
        + ' / '
        + (durationMS / 1000).toFixed(2) + ' sec'
        + ' / '
        + (durationMS / 60 / 1000).toFixed(2) + ' min'
        + ' / '
        + (durationMS / 60 / 60 / 1000).toFixed(1) + ' hr';
};
export { ArrayCalculateAverage, ArrayFindIndexOfHighestValue, Assert, CheckNonNegativeInteger, CheckFloat0to1Exclusive, CheckPositiveInteger, QueueRotate, ThrowCaughtUnknown, ValidateTextForCSV, WriteDurationReport };
//# sourceMappingURL=Utils.js.map</code></pre>
        </article>
    </section>





    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
