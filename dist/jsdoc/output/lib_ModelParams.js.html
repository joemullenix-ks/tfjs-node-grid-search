<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/ModelParams.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/ModelParams.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
import * as Utils from './Utils';
/**
 * Merges two sets of params, dynamic and static, that will be used to create
 * a network model.
 */
class ModelParams {
    /**
     * Creates an instance of ModelParams.
     * @param {Types.StringKeyedSimpleObject} _dynamicParams
     * @param {Types.StringKeyedSimpleObject} _staticParams
     */
    constructor(_dynamicParams, _staticParams) {
        this._dynamicParams = _dynamicParams;
        this._staticParams = _staticParams;
        this._mergedParams = {};
        // start off with a (shallow) clone of the statics...
        this._mergedParams = Object.assign({}, this._staticParams);
        // ...then merge in the dynamics, throwing in the event of a collision
        for (const k in this._dynamicParams) {
            if (this._mergedParams[k] !== undefined) {
                throw new Error('Merging model params with a dynamic-static collision (these are mutually exclusive); key: ' + k);
            }
            this._mergedParams[k] = this._dynamicParams[k];
        }
    }
    /**
     * Retrieve a Boolean param's value.
     * @param {string} key
     * @return {boolean}
     */
    GetBooleanParam(key) {
        this.ValidateParamKey(key);
        if (typeof this._mergedParams[key] !== 'boolean') {
            throw new Error('param ' + key + ' is not Boolean: ' + this._mergedParams[key]);
        }
        return Boolean(this._mergedParams[key]);
    }
    /**
     * Retrieve a number param's value.
     * @param {string} key
     * @return {number}
     */
    GetNumericParam(key) {
        this.ValidateParamKey(key);
        if (typeof this._mergedParams[key] !== 'number') {
            throw new Error('param ' + key + ' is not a number: ' + this._mergedParams[key]);
        }
        return Number(this._mergedParams[key]);
    }
    /**
     * Retrieve a string param's value.
     * @param {string} key
     * @return {string}
     */
    GetTextParam(key) {
        this.ValidateParamKey(key);
        if (typeof this._mergedParams[key] !== 'string') {
            throw new Error('param ' + key + ' is not a string: ' + this._mergedParams[key]);
        }
        return String(this._mergedParams[key]);
    }
    /**
     * Throws if a param key is not supported. This is exceptional because the
     * objects our constructor takes are not user input. They've been processed.
     * @private
     * @param {string} key
     */
    ValidateParamKey(key) {
        Utils.Assert(key !== '');
        if (this._mergedParams[key] === undefined) {
            throw new Error('ModelParams key not found: ' + key);
        }
    }
    //vv TODO: These move into a CSVSource interface
    WriteCSVLineKeys() {
        let textOut = '';
        for (const k in this._mergedParams) {
            textOut += k + ',';
        }
        // drop the trailing comma
        textOut = textOut.slice(0, -1);
        return textOut;
    }
    WriteCSVLineValues() {
        let textOut = '';
        for (const k in this._mergedParams) {
            // check every string for file-breakers, while we're here
            //PERF: This is potentially overkill (we validate these early on in their lifecycle).
            //		I'm keeping it because that initial validation is not done w/ CSV writes in mind. It's much more focused
            //		on proper uint/bool/string.
            //		Redundancy is good, but if our file writes become perceptibly slower, this can go.
            Utils.ValidateTextForCSV(this._mergedParams[k]);
            textOut += this._mergedParams[k] + ',';
        }
        // drop the trailing comma
        textOut = textOut.slice(0, -1);
        return textOut;
    }
}
Object.freeze(ModelParams);
export { ModelParams };
//# sourceMappingURL=ModelParams.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-FileIO.html">FileIO</a></li><li><a href="module-main.html">main</a></li><li><a href="module-Utils.html">Utils</a></li></ul><h3>Classes</h3><ul><li><a href="Axis.html">Axis</a></li><li><a href="AxisSet.html">AxisSet</a></li><li><a href="AxisSetTraverser.html">AxisSetTraverser</a></li><li><a href="DataSet.html">DataSet</a></li><li><a href="DataSetFetcher.html">DataSetFetcher</a></li><li><a href="EpochStats.html">EpochStats</a></li><li><a href="ExponentialProgression.html">ExponentialProgression</a></li><li><a href="FailureMessage.html">FailureMessage</a></li><li><a href="FibonacciProgression.html">FibonacciProgression</a></li><li><a href="FileIOResult.html">FileIOResult</a></li><li><a href="Grid.html">Grid</a></li><li><a href="GridOptions.html">GridOptions</a></li><li><a href="GridRunStats.html">GridRunStats</a></li><li><a href="IterationResult.html">IterationResult</a></li><li><a href="LinearProgression.html">LinearProgression</a></li><li><a href="ModelParams.html">ModelParams</a></li><li><a href="ModelStatics.html">ModelStatics</a></li><li><a href="ModelTestStats.html">ModelTestStats</a></li><li><a href="PredictionEvaluation.html">PredictionEvaluation</a></li><li><a href="Progression.html">Progression</a></li><li><a href="SessionData.html">SessionData</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
